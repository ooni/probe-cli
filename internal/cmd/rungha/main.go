// Command rungha runs github composite GitHub actions locally.
//
// There are three types of GitHub actions:
//
// 1. those using node;
//
// 2. those using docker;
//
// 3. composite actions.
//
// We only support the latter type, which boils down to an action.yaml
// script indicating which commands to execute and specifying which
// input is accepted and what output is generated by an action.
//
// We do not support producing output. We only support reading inputs
// and executing commands using the user-defined shell.
//
// More practically, this script reads all the actions inside of
// .github/actions and generates a command named after the action's
// directory for each action. The generated command allows the
// use to specify input using CLI flags. If an action specifies an
// input named `foo_bar`, we configure the `--foo-bar` flag.
package main

import (
	"fmt"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/google/shlex"
	"github.com/iancoleman/strcase"
	"github.com/spf13/cobra"
	"golang.org/x/sys/execabs"
	"gopkg.in/yaml.v3"
	"mvdan.cc/sh/v3/syntax"
)

// Describes a github action.
//
// Compared to the specification, this data model does not
// include support for emitting output from actions.
//
// See https://docs.github.com/en/actions/creating-actions/metadata-syntax-for-github-actions.
type Action struct {
	// The action's name.
	Name string

	// Brief action's description.
	Description string

	// Action's inputs.
	Inputs map[string]Input

	// How this action runs.
	Runs Runs
}

// Input for an action.
type Input struct {
	// Brief input's description.
	Description string

	// Whether this input must be provided.
	Required bool

	// Default input's value.
	Default string

	// value is the actually parsed value.
	value string
}

// How this action runs.
type Runs struct {
	// Engine to run the action.
	Using string

	// Steps to run.
	Steps []Step
}

// Step is a single step to run.
type Step struct {
	// The shell to use.
	Shell string

	// The command to run.
	Run string
}

// Directory containing a github action.
type ActionDir struct {
	// The directory's path.
	Dirpath string

	// The content of the action parsed from action.yaml.
	Action *Action
}

// A command that executes an action
type CommandAction struct {
	// Dirpath is the directory containing the action.
	Dirpath string

	// The steps of this action
	Steps []Step

	// Modifiable inputs so we can parse it from the CLI (the Inputs
	// field in the YAML struct read from file ends up being immutable
	// because Inputs is map[string]Input, but it would be clumsy
	// to declare it as a map[string]*Input just to allow CLI parsing)
	Inputs map[string]*Input
}

// Creates a CommandAction from an ActionDir
func newCommandAction(act *ActionDir) *CommandAction {
	out := &CommandAction{
		Dirpath: act.Dirpath,
		Steps:   act.Action.Runs.Steps,
		Inputs:  map[string]*Input{},
	}
	for name, input := range act.Action.Inputs {
		out.Inputs[name] = &Input{
			Description: input.Description,
			Required:    input.Required,
			Default:     input.Default,
			value:       "",
		}
	}
	return out
}

func main() {
	basepath := filepath.Join(".github", "actions")
	actions := readActions(basepath)
	root := &cobra.Command{
		Use:   "rungha",
		Short: "Runs composite GitHub actions locally",
	}
	for _, act := range actions {
		ca := newCommandAction(act) // simplified view of the action
		sub := &cobra.Command{
			Use:   filepath.Base(act.Dirpath), // .github/actions/foobar => foobar
			Short: act.Action.Description,
			Run:   ca.Run,
		}
		for name, input := range ca.Inputs { // note: ca.Inputs returns mutable input
			flagname := strcase.ToKebab(name) // foo_bar => foo-bar
			descr := input.Description
			if input.Required {
				descr += " [REQUIRED]" // is there a more idiomatic way in cobra?
			}
			sub.Flags().StringVar(&input.value, flagname, input.Default, descr)
			if input.Required {
				sub.MarkFlagRequired(flagname)
			}
		}
		root.AddCommand(sub)
	}
	if err := root.Execute(); err != nil {
		log.Fatal(err)
	}
}

// Lists the [ActionDir]s below the given [dirpath].
func readActions(basepath string) (out []*ActionDir) {
	entries, err := os.ReadDir(basepath)
	if err != nil {
		log.Fatal(err)
	}
	for _, entry := range entries {
		if !entry.IsDir() {
			continue // skip files
		}
		dirpath := filepath.Join(basepath, entry.Name())
		actionpath := filepath.Join(dirpath, "action.yaml")
		actionDir := &ActionDir{
			Dirpath: dirpath,
			Action:  parseActionFile(actionpath),
		}
		if !canRunAction(actionDir) {
			continue // we don't know how to run this one
		}
		out = append(out, actionDir)
	}
	return
}

// Parses an action file.
func parseActionFile(fullpath string) *Action {
	data, err := os.ReadFile(fullpath)
	if err != nil {
		log.Fatal(err)
	}
	var out Action
	if err := yaml.Unmarshal(data, &out); err != nil {
		log.Fatal(err)
	}
	return &out
}

// canRunAction returns whether this tool can run the action at [dir].
func canRunAction(dir *ActionDir) bool {
	if dir.Action.Runs.Using != "composite" {
		log.Printf("can't run image at %s: not using composite", dir.Dirpath)
		return false
	}
	return true
}

// Runs the given composite github action locally
func (ca *CommandAction) Run(*cobra.Command, []string) {
	for idx, step := range ca.Steps {
		script := buildShellScript(step.Run, ca.Inputs)
		logBeforeRunning(idx, script)
		runScriptWithShell(script, step.Shell, makeEnv(ca.Dirpath))
	}
}

// Merges the current environment with extra environment
// variables that emulate the environment expected by
// composite GitHub actions.
func makeEnv(dirpath string) (out []string) {
	out = os.Environ()
	fullpath, err := filepath.Abs(dirpath)
	if err != nil {
		log.Fatal(err)
	}
	out = append(out, fmt.Sprintf("GITHUB_ACTION_PATH=%s", fullpath))
	return out
}

// Returns the shell script to execute by replacing the input templates
// inside it with the actual values provided from the command line.
func buildShellScript(script string, inputs map[string]*Input) string {
	// Rewrite the original script to use text/template
	for name := range inputs {
		prevPattern := fmt.Sprintf("${{ inputs.%s }}", name)
		newPattern := fmt.Sprintf("{{ .%s }}", name)
		script = strings.ReplaceAll(script, prevPattern, newPattern)
	}

	// Build map to pass to text/template
	mapping := map[string]string{}
	for name, input := range inputs {
		mapping[name] = input.value
	}

	// Execute the template
	tmpl := template.Must(template.New("T1").Parse(script))
	var obuf strings.Builder
	if err := tmpl.Execute(&obuf, mapping); err != nil {
		log.Fatal(err)
	}

	return obuf.String()
}

// Runs a script using the given shell and env.
func runScriptWithShell(script, shell string, env []string) {
	// The following splitting exercise ensures that one can
	// specify something like `/usr/bin/perl -w` as shell
	argv, err := shlex.Split(shell)
	if err != nil {
		log.Fatal(err)
	}
	if len(argv) < 1 {
		log.Fatal("empty argv")
	}
	cmd := execabs.Command(argv[0], argv[1:]...)
	cmd.Env = env
	cmd.Stdin = strings.NewReader(script)
	cmd.Stdout, cmd.Stderr = os.Stdout, os.Stderr
	if err := cmd.Run(); err != nil {
		log.Fatal(err)
	}
}

// Logs the script before actually running it.
func logBeforeRunning(idx int, script string) {
	log.Printf("=== BEGIN SCRIPT #%d ===", idx)
	r := strings.NewReader(script)
	// Let's keep comments in the output to make it even easier
	// to inspect the script we're running
	node, err := syntax.NewParser(syntax.KeepComments(true)).Parse(r, "")
	if err != nil {
		log.Fatal(err)
	}
	var osb strings.Builder
	if err = syntax.NewPrinter().Print(&osb, node); err != nil {
		log.Fatal(err)
	}
	script = strings.TrimRight(osb.String(), "\n") // avoid final empty line
	for _, line := range strings.Split(script, "\n") {
		log.Printf("> %s\n", line)
	}
	log.Printf("=== END SCRIPT #%d ===", idx)
}
