// Package dnsfix implements the dnsfix command.
package dnsfix

import (
	"encoding/csv"
	"errors"
	"fmt"
	"io"
	"os"
	"strconv"
	"time"

	"github.com/ooni/probe-cli/v3/internal/cmd/gardener/internal/testlists"
	"github.com/ooni/probe-cli/v3/internal/fsx"
	"github.com/ooni/probe-cli/v3/internal/runtimex"
	"github.com/schollz/progressbar/v3"
)

// Subcommand is the dnsfix subcommand. The zero value is invalid; please, make
// sure you initialize all the fields marked as MANDATORY.
type Subcommand struct {
	// ReportFile is the MANDATORY file from which to read
	// the results of the dnsreport subcommand.
	ReportFile string
}

// Main is the main function of the dnsfix subcommand. This function calls
// [runtimex.PanicOnError] in case of failure.
func (s *Subcommand) Main() {
	// obtain entries in the file generated by the dnsreport subcommand
	entries := s.collectEntries()

	// create the progress bar to show the user progress
	bar := progressbar.NewOptions64(
		int64(len(entries)),
		progressbar.OptionShowDescriptionAtLineEnd(),
		progressbar.OptionSetWidth(40),
		progressbar.OptionShowCount(),
		progressbar.OptionSetPredictTime(true),
		progressbar.OptionThrottle(65*time.Millisecond),
		progressbar.OptionOnCompletion(func() {
			fmt.Fprint(os.Stdout, "\n")
		}),
		progressbar.OptionSetWriter(os.Stdout),
	)

	// walk through each entry
	for _, entry := range entries {
		_ = bar.Add(1)
		s.processEntry(entry)
	}
}

func (s *Subcommand) collectEntries() (out []*reportEntry) {
	// open file and create CSV reader
	filep := runtimex.Try1(fsx.OpenFile(s.ReportFile))
	reader := csv.NewReader(filep)

	// remember to close the open file
	defer filep.Close()

	// loop through all entries
	var lineno int64
	for {
		// read the current entry
		record, err := reader.Read()
		if errors.Is(err, io.EOF) {
			break
		}
		runtimex.PanicOnError(err, "reader.Read")
		// this record seems malformed but in theory this
		// cannot happen because the csv library should return
		// an error in case we see a short record.
		runtimex.Assert(len(record) == 9, "unexpected record length")

		// skip the first line, which contains the headers
		lineno++
		if lineno == 1 {
			continue
		}

		// add this entry to the list
		out = append(out, newReportEntry(record))
	}

	// return to the caller
	return
}

// reportEntry is an entry generated by dnsreport.
type reportEntry struct {
	file             string
	line             int64
	url              string
	failure          *string
	measurementCount int64
	anomalyCount     int64
	confirmedCount   int64
	okCount          int64
	failureCount     int64
}

// newReportEntry generates a report entry from a CSV record.
func newReportEntry(record []string) *reportEntry {
	runtimex.Assert(len(record) == 9, "unexpected record length")
	return &reportEntry{
		file:             record[0],
		line:             runtimex.Try1(strconv.ParseInt(record[1], 10, 64)),
		url:              record[2],
		failure:          &record[3],
		measurementCount: runtimex.Try1(strconv.ParseInt(record[4], 10, 64)),
		anomalyCount:     runtimex.Try1(strconv.ParseInt(record[5], 10, 64)),
		confirmedCount:   runtimex.Try1(strconv.ParseInt(record[6], 10, 64)),
		okCount:          runtimex.Try1(strconv.ParseInt(record[7], 10, 64)),
		failureCount:     runtimex.Try1(strconv.ParseInt(record[8], 10, 64)),
	}
}

// processEntry processes the given entry and possibly edits
// the test lists to remove selected URLs from it.
func (s *Subcommand) processEntry(entry *reportEntry) {
	// skip entries we have not measured
	if entry.measurementCount <= 0 {
		return
	}

	// skip entries with anomaly or confirmed
	if entry.anomalyCount > 0 || entry.confirmedCount > 0 {
		return
	}

	// remove this entry from the test lists
	testlists.Rewrite(entry.file, func(URL string) bool {
		return URL != entry.url
	})
}
