package measurex

import (
	"context"
	"net"
	"time"

	"github.com/ooni/probe-cli/v3/internal/netxlite"
	"github.com/ooni/probe-cli/v3/internal/netxlite/errorsx"
)

// Conn is like net.Conn but also knows its ConnID and has a
// reference to its Dialer's database. On Read, Write, and Close, this
// Conn will write a specific event into the database.
type Conn interface {
	net.Conn

	// ConnID returns the ConnID. This should be a positive
	// integer. A zero or negative value means "unknown".
	ConnID() int64
}

// Dialer is like netxlite.Dialer but dials connections of
// the Conn type defined inside this package.
type Dialer interface {
	// DialContext wraps a netxlite.Dialer.DialContext
	// and implements this algorithm:
	//
	// 1. perform TCP/UDP dial using the underlying netxlite.Dialer;
	//
	// 2. insert a DialEvent into the DB;
	//
	// 3. on error, return error;
	//
	// 4. otherwise, wrap the net.Conn to be a Conn and return it.
	DialContext(ctx context.Context, network, address string) (Conn, error)

	// CloseIdleConnections calls the namesake method
	// of the underlying netxlite.Dialer.
	CloseIdleConnections()
}

// WrapDialer takes in input a netxlite.Dialer and returns
// in output a Dialer of the type used in this package.
//
// Arguments:
//
// - origin is either OriginProbe or OriginTH
//
// - db is the database in which to store measurements
//
// - d is the underlying netxlite.Dialer to use
func WrapDialer(origin Origin, db EventDB, d netxlite.Dialer) Dialer {
	return &dialerx{Dialer: d, db: db, origin: origin}
}

// NewDialerWithoutResolver is a convenience factory for creating
// a dialer that saves measurements into the DB and that is not attached
// to any resolver (hence only works when passed IP addresses).
func NewDialerWithoutResolver(origin Origin, db EventDB, logger Logger) Dialer {
	return WrapDialer(origin, db, netxlite.NewDialerWithoutResolver(
		logger,
	))
}

// netxliteDialerAdapter adapts measurex.Dialer to netxlite.Dialer.
type netxliteDialerAdapter struct {
	Dialer
}

// DialContext implements netxlite.Dialer.DialContext.
func (d *netxliteDialerAdapter) DialContext(
	ctx context.Context, network, address string) (net.Conn, error) {
	return d.Dialer.DialContext(ctx, network, address)
}

// NewDialerWithSystemResolver is a convenience factory for creating
// a dialer that saves measurements into mx.DB and uses the system resolver.
func NewDialerWithSystemResolver(origin Origin, db EventDB, logger Logger) Dialer {
	r := NewResolverSystem(origin, db, logger)
	return WrapDialer(origin, db, netxlite.NewDialerWithResolver(
		logger, r,
	))
}

type dialerx struct {
	netxlite.Dialer
	db     EventDB
	origin Origin
}

// NetworkEvent contains a network event. This kind of events
// are generated by Dialer, QUICDialer, Conn, QUICConn.
type NetworkEvent struct {
	Origin        Origin        // OriginProbe or OriginTH
	MeasurementID int64         // ID of the measurement
	ConnID        int64         // ID of the conn
	Operation     string        // "read", "write", ...
	Network       string        // "tcp", "udp"
	RemoteAddr    string        // remote addr (e.g., "1.1.1.1:443")
	LocalAddr     string        // local addr
	Started       time.Duration // when we called dial
	Finished      time.Duration // when dial returned
	Error         error         // error or nil
	Oddity        Oddity        // oddity classification
	Count         int           // bytes sent or recv (where applicable)
}

func (d *dialerx) DialContext(
	ctx context.Context, network, address string) (Conn, error) {
	connID := d.db.NextConnID()
	started := d.db.ElapsedTime()
	conn, err := d.Dialer.DialContext(ctx, network, address)
	finished := d.db.ElapsedTime()
	d.db.InsertIntoDial(&NetworkEvent{
		Origin:        d.origin,
		MeasurementID: d.db.MeasurementID(),
		ConnID:        connID,
		Operation:     "connect",
		Network:       network,
		RemoteAddr:    address,
		LocalAddr:     d.localAddrIfNotNil(conn),
		Started:       started,
		Finished:      finished,
		Error:         err,
		Oddity:        d.computeOddity(err),
		Count:         0,
	})
	if err != nil {
		return nil, err
	}
	return &connx{
		Conn:       conn,
		db:         d.db,
		connID:     connID,
		remoteAddr: address,
		localAddr:  conn.LocalAddr().String(),
		network:    network,
		origin:     d.origin,
	}, nil
}

func (c *dialerx) localAddrIfNotNil(conn net.Conn) (addr string) {
	if conn != nil {
		addr = conn.LocalAddr().String()
	}
	return
}

func (c *dialerx) computeOddity(err error) Oddity {
	if err == nil {
		return ""
	}
	switch err.Error() {
	case errorsx.FailureGenericTimeoutError:
		return OddityTCPConnectTimeout
	case errorsx.FailureConnectionRefused:
		return OddityTCPConnectRefused
	case errorsx.FailureHostUnreachable:
		return OddityTCPConnectHostUnreachable
	default:
		return OddityTCPConnectOher
	}
}

type connx struct {
	net.Conn
	db         EventDB
	connID     int64
	remoteAddr string
	localAddr  string
	network    string
	origin     Origin
}

func (c *connx) ConnID() int64 {
	return c.connID
}

func (c *connx) Read(b []byte) (int, error) {
	started := c.db.ElapsedTime()
	count, err := c.Conn.Read(b)
	finished := c.db.ElapsedTime()
	c.db.InsertIntoReadWrite(&NetworkEvent{
		Origin:        c.origin,
		MeasurementID: c.db.MeasurementID(),
		ConnID:        c.connID,
		Operation:     "read",
		Network:       c.network,
		RemoteAddr:    c.remoteAddr,
		LocalAddr:     c.localAddr,
		Started:       started,
		Finished:      finished,
		Error:         err,
		Count:         count,
	})
	return count, err
}

func (c *connx) Write(b []byte) (int, error) {
	started := c.db.ElapsedTime()
	count, err := c.Conn.Write(b)
	finished := c.db.ElapsedTime()
	c.db.InsertIntoReadWrite(&NetworkEvent{
		Origin:        c.origin,
		MeasurementID: c.db.MeasurementID(),
		ConnID:        c.connID,
		Operation:     "write",
		Network:       c.network,
		RemoteAddr:    c.remoteAddr,
		LocalAddr:     c.localAddr,
		Started:       started,
		Finished:      finished,
		Error:         err,
		Count:         count,
	})
	return count, err
}

func (c *connx) Close() error {
	started := c.db.ElapsedTime()
	err := c.Conn.Close()
	finished := c.db.ElapsedTime()
	c.db.InsertIntoClose(&NetworkEvent{
		Origin:        c.origin,
		MeasurementID: c.db.MeasurementID(),
		ConnID:        c.connID,
		Operation:     "close",
		Network:       c.network,
		RemoteAddr:    c.remoteAddr,
		LocalAddr:     c.localAddr,
		Started:       started,
		Finished:      finished,
		Error:         err,
		Count:         0,
	})
	return err
}
