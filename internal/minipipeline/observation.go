package minipipeline

import (
	"errors"
	"net"
	"net/url"
	"strconv"
	"strings"

	"github.com/ooni/probe-cli/v3/internal/geoipx"
	"github.com/ooni/probe-cli/v3/internal/measurexlite"
	"github.com/ooni/probe-cli/v3/internal/model"
	"github.com/ooni/probe-cli/v3/internal/netxlite"
	"github.com/ooni/probe-cli/v3/internal/optional"
)

// ErrNoTestKeys indicates that a [*Measurement] does not contain [*MeasurementTestKeys].
var ErrNoTestKeys = errors.New("minipipeline: no test keys")

// LoadWebMeasurement loads a [*Measurement] into a [*WebObservationsContainter].
func LoadWebMeasurement(meas *Measurement) (*WebObservationsContainer, error) {
	tk := meas.TestKeys.UnwrapOr(nil)
	if tk == nil {
		return nil, ErrNoTestKeys
	}

	container := NewWebObservationsContainer()
	container.CreateDNSLookupFailures(tk.Queries...)
	container.CreateKnownIPAddresses(tk.Queries...)
	container.CreateKnownTCPEndpoints(tk.TCPConnect...)
	container.NoteTLSHandshakeResults(tk.TLSHandshakes...)
	container.NoteHTTPRoundTripResults(tk.Requests...)

	// be defensive in case the control request or control are not defined
	if !tk.XControlRequest.IsNone() && !tk.Control.IsNone() {
		// Implementation note: the only error that can happen here is when the input
		// doesn't parse as a URL, which should have triggered previous errors
		if err := container.NoteControlResults(tk.XControlRequest.Unwrap(), tk.Control.Unwrap()); err != nil {
			return nil, err
		}
	}

	return container, nil
}

// WebObservation is an observation of the flow that starts with a DNS lookup that
// discovers zero or more IP addresses and proceeds with endpoint operations such as
// TCP connect, TLS handshake, QUIC handshake, and HTTP round trips.
//
// A key property of the [WebObservation] is that there is a single failure mode
// for the whole [WebObservation]. If the DNS fails, there are no IP addresses to
// construct endpoints. If TCP connect fails, there is no connection to use for
// a TLS handshake. If QUIC fails, there is no connection. If there is no connection
// we cannot attempt sending an HTTP request, so there's no HTTP round trip.
//
// We borrow this design from https://github.com/ooni/data.
type WebObservation struct {
	// DNSTransactionIDs contains the IDs of the DNS transactions that caused this
	// specific [WebObservation] to be generated by the mini pipeline.
	DNSTransactionIDs optional.Value[[]int64]

	// DNSDomain is the domain from which we resolved the IP address. This field
	// is empty whne this record wasn't generated by a DNS lookup.
	DNSDomain optional.Value[string]

	// DNSLookupFailure is the failure that occurred during the DNS lookup.
	DNSLookupFailure optional.Value[string]

	// DNSQueryType is the type of the DNS query.
	DNSQueryType optional.Value[string]

	// DNSEngine is the DNS engine that we're using.
	DNSEngine optional.Value[string]

	// IPAddress is the optional IP address that this observation is about. We derive this value
	// either from one or more DNS lookups, or because it's part of the input URL. When it's
	// empty, it means the associated DNS lookup operation failed.
	IPAddress optional.Value[string]

	// IPAddressASN is the optional ASN associated to this IP address as discovered by
	// the probe while performing the measurement. When this field is empty, it means
	// that the probe failed to discover the IP address ASN.
	IPAddressASN optional.Value[int64]

	// IPAddressOrg is the optional organization name associated to this IP adddress
	// as discovered by the probe while performing the measurement. When this field is
	// empty, it means that the probe failed to discover the IP address org.
	IPAddressOrg optional.Value[string]

	// IPAddressBogon is true if IPAddres is a bogon.
	IPAddressBogon optional.Value[bool]

	// EndpointTransactionID is the transaction ID used by this endpoint.
	EndpointTransactionID optional.Value[int64]

	// EndpointProto is either "tcp" or "udp".
	EndpointProto optional.Value[string]

	// EndpointPort is the port used by this endpoint.
	EndpointPort optional.Value[string]

	// EndpointAddress is "${IPAddress}:${EndpointPort}" where "${IPAddress}" is
	// quoted using "[" and "]" in case of IPv6.
	EndpointAddress optional.Value[string]

	// TCPConnectFailure is the optional TCP connect failure.
	TCPConnectFailure optional.Value[string]

	// TLSHandshakeFailure is the optional TLS handshake failure.
	TLSHandshakeFailure optional.Value[string]

	// TLSServerName is the optional TLS server name used.
	TLSServerName optional.Value[string]

	// HTTPRequestURL is the HTTP request URL.
	HTTPRequestURL optional.Value[string]

	// HTTPFailure is the error that occurred.
	HTTPFailure optional.Value[string]

	// HTTPResponseStatusCode is the response status code.
	HTTPResponseStatusCode optional.Value[int64]

	// HTTPResponseBodyLength is the length of the response body.
	HTTPResponseBodyLength optional.Value[int64]

	// HTTPResponseBodyIsTruncated indicates whether the response body is truncated.
	HTTPResponseBodyIsTruncated optional.Value[bool]

	// HTTPResponseHeadersKeys contains the response headers keys.
	HTTPResponseHeadersKeys optional.Value[map[string]bool]

	// HTTPResponseLocation contains the location we're redirected to.
	HTTPResponseLocation optional.Value[string]

	// HTTPResponseTitle contains the response title.
	HTTPResponseTitle optional.Value[string]

	// HTTPResponseIsFinal is true if the status code is 2xx, 4xx, or 5xx.
	HTTPResponseIsFinal optional.Value[bool]

	// ControlDNSDomain is the domain used by the control for its DNS lookup. This
	// field is set only when the domain used by the control matches the domain
	// used by the probe. So, we won't see this record for redirects using a different domain.
	ControlDNSDomain optional.Value[string]

	// ControlDNSLookupFailure is the corresponding control DNS lookup failure.
	ControlDNSLookupFailure optional.Value[string]

	// ControlTCPConnectFailure is the control's TCP connect failure.
	ControlTCPConnectFailure optional.Value[string]

	// MatchWithControlIPAddress is true if also the control resolved this IP address.
	MatchWithControlIPAddress optional.Value[bool]

	// MatchWithControlIPAddressASN is true if also the control resolved from the same ASN.
	MatchWithControlIPAddressASN optional.Value[bool]

	// ControlTLSHandshakeFailure is the control's TLS handshake failure.
	ControlTLSHandshakeFailure optional.Value[string]

	// ControlHTTPFailure is the failure seen by the control.
	ControlHTTPFailure optional.Value[string]

	// ControlHTTPResponseStatusCode is the status code seen by the control.
	ControlHTTPResponseStatusCode optional.Value[int64]

	// ControlHTTPResponseBodyLength contains the control HTTP response body length.
	ControlHTTPResponseBodyLength optional.Value[int64]

	// ControlHTTPResponseHeadersKeys contains the response headers keys.
	ControlHTTPResponseHeadersKeys optional.Value[map[string]bool]

	// ControlHTTPResponseTitle contains the title seen by the control.
	ControlHTTPResponseTitle optional.Value[string]
}

// WebObservationsContainer contains [*WebObservations].
//
// The zero value of this struct is not ready to use, please use [NewWebObservationsContainer].
type WebObservationsContainer struct {
	// DNSLookupFailures maps domain names to DNS lookup failures.
	DNSLookupFailures map[int64]*WebObservation

	// KnownTCPEndpoints maps a transaction ID to the corresponding observation.
	KnownTCPEndpoints map[int64]*WebObservation

	// knownIPAddresses maps an IP address to the corresponding observation.
	knownIPAddresses map[string]*WebObservation
}

// NewWebObservationsContainer constructs a [*WebObservationsContainer].
func NewWebObservationsContainer() *WebObservationsContainer {
	return &WebObservationsContainer{
		DNSLookupFailures: map[int64]*WebObservation{},
		KnownTCPEndpoints: map[int64]*WebObservation{},
		knownIPAddresses:  map[string]*WebObservation{},
	}
}

// CreateDNSLookupFailures creates records for failed DNS lookups.
func (c *WebObservationsContainer) CreateDNSLookupFailures(evs ...*model.ArchivalDNSLookupResult) {
	for _, ev := range evs {
		// skip all the succesful queries
		if ev.Failure == nil {
			continue
		}

		// create record
		obs := &WebObservation{
			DNSTransactionIDs: optional.Some([]int64{ev.TransactionID}),
			DNSDomain:         optional.Some(ev.Hostname),
			DNSLookupFailure:  optional.Some(utilsStringPointerToString(ev.Failure)),
			DNSQueryType:      optional.Some(ev.QueryType),
			DNSEngine:         optional.Some(ev.Engine),
		}

		// add record
		c.DNSLookupFailures[ev.TransactionID] = obs
	}
}

// CreateKnownIPAddresses creates known IP addresses from succesful DNS lookups.
func (c *WebObservationsContainer) CreateKnownIPAddresses(evs ...*model.ArchivalDNSLookupResult) {
	for _, ev := range evs {
		// skip all the failed queries
		if ev.Failure != nil {
			continue
		}

		// walk through the answers
		for _, answer := range ev.Answers {
			// extract the IP address we resolved
			var addr string
			switch answer.AnswerType {
			case "A":
				addr = answer.IPv4
			case "AAAA":
				addr = answer.IPv6
			default:
				continue
			}

			// create or fetch a record
			obs, found := c.knownIPAddresses[addr]
			if !found {
				obs = &WebObservation{}
				c.knownIPAddresses[addr] = obs
			}

			// update the record
			obs.DNSTransactionIDs = optional.Some(append(obs.DNSTransactionIDs.UnwrapOr([]int64{}), ev.TransactionID))
			obs.DNSDomain = optional.Some(ev.Hostname)
			obs.DNSLookupFailure = optional.Some("")
			obs.DNSQueryType = optional.Some(ev.QueryType)
			obs.DNSEngine = optional.Some(ev.Engine)
			obs.IPAddress = optional.Some(addr)
			if asn, asOrg, err := geoipx.LookupASN(addr); err == nil {
				obs.IPAddressASN = optional.Some(int64(asn))
				obs.IPAddressOrg = optional.Some(asOrg)
			}
			obs.IPAddressBogon = optional.Some(netxlite.IsBogon(addr))
		}
	}
}

// CreateKnownTCPEndpoints creates known TCP endpoints from TCP connect attempts.
func (c *WebObservationsContainer) CreateKnownTCPEndpoints(evs ...*model.ArchivalTCPConnectResult) {
	for _, ev := range evs {
		// create or fetch a record
		obs, found := c.knownIPAddresses[ev.IP]
		if !found {
			obs = &WebObservation{
				IPAddress:      optional.Some(ev.IP),
				IPAddressBogon: optional.Some(netxlite.IsBogon(ev.IP)),
			}
			if asn, asOrg, err := geoipx.LookupASN(ev.IP); err == nil {
				obs.IPAddressASN = optional.Some(int64(asn))
				obs.IPAddressOrg = optional.Some(asOrg)
			}
		}

		// clone the record because the same IP address MAY belong
		// to multiple endpoints across the same measurement
		//
		// while there also fill endpoint specific info
		portString := strconv.Itoa(ev.Port)
		obs = &WebObservation{
			DNSTransactionIDs:     optional.Some(append([]int64{}, obs.DNSTransactionIDs.UnwrapOr([]int64{})...)),
			DNSDomain:             obs.DNSDomain,
			DNSLookupFailure:      obs.DNSLookupFailure,
			IPAddress:             obs.IPAddress,
			IPAddressASN:          obs.IPAddressASN,
			IPAddressOrg:          obs.IPAddressOrg,
			IPAddressBogon:        obs.IPAddressBogon,
			EndpointTransactionID: optional.Some(ev.TransactionID),
			EndpointProto:         optional.Some("tcp"),
			EndpointPort:          optional.Some(portString),
			EndpointAddress:       optional.Some(net.JoinHostPort(ev.IP, portString)),
			TCPConnectFailure:     optional.Some(utilsStringPointerToString(ev.Status.Failure)),
		}

		// register the observation
		c.KnownTCPEndpoints[ev.TransactionID] = obs
	}
}

// NoteTLSHandshakeResults updates endpoints taking into account TLS handshake results.
func (c *WebObservationsContainer) NoteTLSHandshakeResults(evs ...*model.ArchivalTLSOrQUICHandshakeResult) {
	for _, ev := range evs {
		// find the corresponding obs
		obs, found := c.KnownTCPEndpoints[ev.TransactionID]
		if !found {
			continue
		}

		// update the record
		obs.TLSHandshakeFailure = optional.Some(utilsStringPointerToString(ev.Failure))
		obs.TLSServerName = optional.Some(ev.ServerName)
	}
}

// NoteHTTPRoundTripResults updates endpoints taking into account HTTP round trip results.
func (c *WebObservationsContainer) NoteHTTPRoundTripResults(evs ...*model.ArchivalHTTPRequestResult) {
	for _, ev := range evs {
		// find the corresponding obs
		obs, found := c.KnownTCPEndpoints[ev.TransactionID]
		if !found {
			continue
		}

		// update the record
		obs.HTTPRequestURL = optional.Some(ev.Request.URL)
		obs.HTTPFailure = optional.Some(utilsStringPointerToString(ev.Failure))
		obs.HTTPResponseStatusCode = optional.Some(ev.Response.Code)
		obs.HTTPResponseBodyLength = optional.Some(int64(len(ev.Response.Body)))
		obs.HTTPResponseBodyIsTruncated = optional.Some(ev.Request.BodyIsTruncated)

		httpResponseHeadersKeys := make(map[string]bool)
		for key := range ev.Response.Headers {
			httpResponseHeadersKeys[key] = true
		}
		obs.HTTPResponseHeadersKeys = optional.Some(httpResponseHeadersKeys)

		if value := measurexlite.WebGetTitle(string(ev.Response.Body)); value != "" {
			obs.HTTPResponseTitle = optional.Some(value)
		}
		for key, value := range ev.Response.Headers {
			if strings.ToLower(key) == "location" {
				obs.HTTPResponseLocation = optional.Some(string(value))
			}
		}

		obs.HTTPResponseIsFinal = optional.Some((func() bool {
			switch ev.Response.Code / 100 {
			case 2, 4, 5:
				return true
			default:
				return false
			}
		}()))
	}
}

// NoteControlResults takes note of the control's results and updates observations accordingly.
func (c *WebObservationsContainer) NoteControlResults(req *model.THRequest, resp *model.THResponse) error {

	URL, err := url.Parse(req.HTTPRequest)
	if err != nil {
		return err
	}
	inputDomain := URL.Hostname()

	c.controlXrefDNSQueries(inputDomain, resp)
	c.controlMatchDNSLookupResults(inputDomain, resp)
	c.controlXrefTCPIPFailures(resp)
	c.controlXrefTLSFailures(resp)
	c.controlSetHTTPFinalResponseExpectation(resp)

	return nil
}

func (c *WebObservationsContainer) controlMatchDNSLookupResults(inputDomain string, resp *model.THResponse) {
	// map out all the IP addresses resolved by the TH
	thAddrMap := make(map[string]bool)
	for _, addr := range resp.DNS.Addrs {
		thAddrMap[addr] = true
	}

	// map out all the ASN discovered by the TH using the same ASN
	// database used to build the probe's ASN mapping
	thASNMap := make(map[int64]bool)
	for _, addr := range resp.DNS.Addrs {
		if asn, _, err := geoipx.LookupASN(addr); err == nil && asn != 0 {
			thASNMap[int64(asn)] = true
		}
	}

	// walk through the list of known observations
	for _, obs := range c.KnownTCPEndpoints {
		// obtain the domain from which we obtained the endpoint's address
		domain := obs.DNSDomain.UnwrapOr("")

		// obtain the IP address
		addr := obs.IPAddress.Unwrap()

		// handle the case from which the IP address has been provided by the control, which
		// is a case where the domain is empty and the IP address is in thAddrMap
		if domain == "" && thAddrMap[addr] {
			obs.MatchWithControlIPAddress = optional.Some(true)
			obs.MatchWithControlIPAddressASN = optional.Some(true)
			continue
		}

		// skip entries using a different domain than the one used by the TH
		if domain == "" || domain != inputDomain {
			continue
		}

		// compute whether also the TH observed this addr
		obs.MatchWithControlIPAddress = optional.Some(thAddrMap[addr])

		// cannot continue unless we know the probe's ASN
		ourASN := obs.IPAddressASN.UnwrapOr(0)
		if ourASN <= 0 {
			continue
		}

		// register whether there is matching in terms of the ASNs
		obs.MatchWithControlIPAddressASN = optional.Some(thASNMap[ourASN])
	}
}

func (c *WebObservationsContainer) controlXrefDNSQueries(inputDomain string, resp *model.THResponse) {
	for _, obs := range c.DNSLookupFailures {
		// skip cases where the input domain is different
		if obs.DNSDomain.Unwrap() != inputDomain {
			continue
		}

		// register the corresponding DNS domain used by the control
		obs.ControlDNSDomain = optional.Some(inputDomain)

		// register the corresponding DNS lookup failure
		obs.ControlDNSLookupFailure = optional.Some(utilsStringPointerToString(resp.DNS.Failure))
	}
}

func (c *WebObservationsContainer) controlXrefTCPIPFailures(resp *model.THResponse) {
	for _, obs := range c.KnownTCPEndpoints {
		endpointAddress := obs.EndpointAddress.Unwrap()

		// skip when we don't have a record
		tcp, found := resp.TCPConnect[endpointAddress]
		if !found {
			continue
		}

		// if there is a failure, save it
		obs.ControlTCPConnectFailure = optional.Some(utilsStringPointerToString(tcp.Failure))
	}
}

func (c *WebObservationsContainer) controlXrefTLSFailures(resp *model.THResponse) {
	for _, obs := range c.KnownTCPEndpoints {
		endpointAddress := obs.EndpointAddress.Unwrap()

		// skip entries without a TLS server name (e.g., entries where we did not TLS handshake)
		//
		// this check should be ~first to exclude cases w/o TLS
		if obs.TLSServerName.IsNone() {
			continue
		}
		serverName := obs.TLSServerName.Unwrap()

		// skip when we don't have a record
		tls, found := resp.TLSHandshake[endpointAddress]
		if !found {
			continue
		}

		// skip when the server name does not match
		if tls.ServerName != serverName {
			continue
		}

		// if there is a failure, save it
		obs.ControlTLSHandshakeFailure = optional.Some(utilsStringPointerToString(tls.Failure))
	}
}

func (c *WebObservationsContainer) controlSetHTTPFinalResponseExpectation(resp *model.THResponse) {
	// Implementation note: the TH response does not have a clear semantics for "missing" values
	// therefore we are accepting as valid only values within the correct range
	for _, obs := range c.KnownTCPEndpoints {
		obs.ControlHTTPFailure = optional.Some(utilsStringPointerToString(resp.HTTPRequest.Failure))
		if value := resp.HTTPRequest.StatusCode; value > 0 {
			obs.ControlHTTPResponseStatusCode = optional.Some(value)
		}
		if value := resp.HTTPRequest.BodyLength; value >= 0 {
			obs.ControlHTTPResponseBodyLength = optional.Some(value)
		}

		controlHTTPResponseHeadersKeys := make(map[string]bool)
		for key := range resp.HTTPRequest.Headers {
			controlHTTPResponseHeadersKeys[key] = true
		}
		if len(controlHTTPResponseHeadersKeys) > 0 {
			obs.ControlHTTPResponseHeadersKeys = optional.Some(controlHTTPResponseHeadersKeys)
		}

		if v := resp.HTTPRequest.Title; v != "" {
			obs.ControlHTTPResponseTitle = optional.Some(v)
		}
	}
}
